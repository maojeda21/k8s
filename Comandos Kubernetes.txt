-- KUBERNETES --

Minikube: es una herramienta que nos permite crear un cluster local, simula un entorno de Kubernetes.

start: arranca un cluster de Kubernetes de manera local.
    minikube start

status: para ver el estado de nuestro cluster.
    minikube status

Virtual Box: por defecto minikube usa docker como generador de maquina virtual, si queremos usar virtual box ejecutamos el siguiente comando.
    minikube start --driver=virtualbox

dashboard: para abrir un dashboard en un navegador web donde podemos ver y monitorar nuestro cluster de Kubernetes.
    minikube dashboard

logs: permite ver los logs del cluster.
    minikube logs

ip: permite ver la configuracion y la IP que se asigno al servidor del cluster.
    minikube ip

ssh: podemos loguearnos dentro de la maquina virtual que hemos creado con minikube.
    minikube ssh

update-check: permite comprobar si hay una version mas nueva de minikube.
    minikube update-check

kubectl: herramienta basica para Kubernete, similar al comando docker que nos permite ejecutar instruciones en docker.

cluster-info: muestra informacion del cluster.
    kubectl cluster-info

get: permite visualizar los elementos, servicios y demas componentes del cluster.
    kubectl get (algun servicio o elemento)
    kubectl get nodes
    kubectl get pods
    kubectl get deployment
    kubectl get services/svc

-o wide: brinda mayor informacion de los pods, deploy, servicios y nodos.
    kubectl get pods -o wide

describe: secribe un determinado servicio o pods, similar al inspect de docker.
    kubectl describe pods (describe todos los pods)
    kubectl describe pod/(nombre-pod)
    kubectl describe deployments (describe todos los deployments)
    kubectl describe deploy (nombre-deploy)

run: se usa para hacer un deployment/despliegue, funciona igual que el run de docker, pero cambia las demas sintaxis.
    kubectl run nombre-del-contenedor --image=nombre-de-la-imagen
    kubectl run n1 --image=nginx

create: crea un deployment, un deployment es un conjunto de instrucciones para que un contenedor pueda funcionar en un pod
    kubectl create deployment (nombre-deployment) --image=(nombre-de-la-imagen)
    kubectl create deployment hello-world --image=nginx
    kubectl delete -n default deployment nginx-deployment (comando sacado del dashboard)

logs: muestra lo que esta haciendo o ejecutando dentro del pod
    kubectl logs pod/(nombre-pod)
    kubectl logs pod/n1

proxy: nos permite acceder desde el exterior al interior de la red que usan los pods o contenedores.
    kubectl proxy
    - Luego entrando al navegador mediante la dirccion del localhost con el puerto 8001 veremos las apis necesarias para acceder a los componentes del cluster.
    - Por ej, para entrar al contenedor de nginx mediante el navegador: http://localhost:8001/api/v1/namespaces/default/pods/n1/proxy/

exec: ejecuta comando dentro del contenedor, como en docker.
    kubectl exec nombre-pod (comando a ejectuar)
    kubectl exec n1 bash/ls

expose: es la manera mas sencilla de crear un servicio (crea un servicio para exponer un deployment).
    kubectl expose (nombre del servicio) --type="NodePort" --port 80 (hay varios tipos de "type")
    kubectl expose deployments/nginx1 --type="NodePort" --port 80

El archivo de configuracion de kubectl se encuentra dentro de la carpeta oculta .kube, el archivo config.

El archivo de configuracion de minikube se encuentra dentro de la carpeta ocula .minikube, el archivo config.

El o los cluster creados por minikube lo podemos ver dentro del directorio oculto .minikube/machines

--container-runtime=cri-o: arrancar una maquina virtual con otro tipo de conteiner runtime.
    minikube start --container-runtime=crio-o

-p: crear otro cluster con otro perfil(-p de perfil)
    minikube start -p (nombre del perfil)
    minikube start -p desarrollo

profile: permite ver en que cluster estamos.
    minikube profile

profile list: nos da una lista de los cluster que tenemos.
    minikube profile list

- Con profile nos podemos mover entre los distintos cluster que tengamos.
    minikube profile (nombre del cluster)

    -- PODS --

Es el objeto minimo que podemos encontrar en Kubernetes.
Normalmente un POD contiene un contenedor, un pod tiene un  conjunto de recursos propios, como ser, RAM, procesador, direcciones de red, puertos, hostname, 
volumenes, incluso una direccion de red unica, estos pods se crean en un cluster, el pod se comunica con los demas pods por una net virtual privada dentro de Kubernetes.
no se deben guardar nada dentro de los pods.

1. IMPERATIVO: despliega una aplicación en un POD, un POD es como una burbuja donde dentro de el se ejecutan uno o varios contenedores.

2. DELARATIVO: se hace atra vez de archivos MANIFEST(YAML)

run: crear un pod de manera automatica que se cree y se ejecute en ese momento y con el que podamos interactuar.
    kubectl run nginx1 --image=nginx

describe (componente/type): se ejecuta el comando describe seuido de algun pods/services/deployments.
    kubectl describe pod/n1

exec: permite ejecutar un comando contra un contenedor, igual que el exce de docker.
    kubectl exec nombre-pod comando-a-introducir
    kubectl exec n1 ls
    kubectl exec n1 -it bash

--port= : para exponer el puerto de un contenedor/pod.
    kubectl run apache --image=httpd --port=8080

logs: para ver los logs de un pod.
    kubectl logs (nombre-pod)
    kubectl logs apache
    - con el parametro -f se queda esperando el log.
    kubectl logs -f apache
    - con el parametro --tail= le podemos indicar el numero de lineas que queremos ver de los logs.
    kubectl logs apache --tail=30
    - en el caso de tener mas de un contenedor corriendo en un mismo pod tengo que decirle a kubectl cual de los dos quiero con me muestro, con el parametro -c
    kubectl logs pod/nombre-del-pod -c (nombre-del-contenedor)
    kubectl logs pod/redis-django -c almacen --> tenemos dos contenedores, uno llamdo "almacen", y el otro "frontal"
     
 -- FICHERO YAML --

# Las cadenas no requieren comillas:
Titulo: Introcuccion a TAML
# Pero se pueden usar:
title-w-quotes: 'Intruccion a TAML' -> properties:'valor'

# Las cadenas multilineas comienzan con |
ejecutar: |
    npm cr
    npm build
    prueba npm

# Secuencias
# Las secuencias nos permiten definir listas en YAML:
# Una lista de números usando guiones:
números:
    - uno
    - dos 
    - Tres

# La version en linea:
numeros: [uno, dos, tres]

# Valores anidados
# Podemos usar todos los tipos anteriores para crear un objeto con valores anidados, asi:
# Mil novecientos ochenta y cuatro datos nuevos.
1984:
    autor:  Cosme Fulanito
    publicado en: 1949-06-08
    recuento de paginas: 328
    descripcion: |
        Una novela, a menudo publicada como 1984, es una novela distopica del novelista ingles Cosme Fulanito.
        Fue publicado en Junio de 1949 por Secker & Warburg como noveno y ultimo b de Orwell.

# Lista de objetos
# Combinando secuencias y valores anidados podemos crear una lista de objetos.
# Hagamos una lista de libros:
- 1984:
    autor: Coste Fulanito
    publicado en: 1949-06-08
    recuento de paginas: 328
    descripcion: |
        Una novela, a menudo publicada como 1984, es una novela distopica del novelista ingles Cosme Fulanito.

- el Hobbit:
    autor: J. R. R. Tolkien
    publicado en: 1937-09-21
    recuento de paginas: 310
    descripcion: |
        The Hobbit, o There and back Again es una novela de fantasía para niños del autor ingles J. R. R. Tolkien

-----------------------------------------

create: nos permite crear un recurso o un componente de Kubernetes a partir de un fichero YAML, se le pasa el parametro -f.
    kubectl create -f (nombre-fichero-.yaml)
    kubectl create -f nginx.yaml

delete: nos permite borrar un pod del cluster.
    kubectl delete pod/(nombre-del-pod) -> tambien se puede usarl sin la barra "/"
    kubectl delete pod (nombre-del-pod)
    kubectl delete pod/n1
    kubectl delete -n default pod nginx-deployment-66b6c48dd5-wfzbm (comando sacado del dashboard) 
    --grace-period= : se le puede dar un tiempo de "gracias" antes de borrar.
    kubectl delete pod apache --grace-period=(tiempo-en-segundos)
    kubectl delete pod apache --grace-period=10
    -now: borra el pod de manera inmediata y que no espere nada.
    kubectl delete pod apache --now
    --all: borra todos los pod (no pregunta si queremos hacerlo)
    kubectl delete pods --all

get pod (YAML o JSON): permite obtener informacion de un determinado pod ya sea en formato yaml o json.
    kubectl get pod/(nombre-del-pod) -o (YAML/JSON)
    kubectl get pod/n1 -o yaml

apply: uno de los comandos con lo que podemos trabajar de manera declarativa. usamos este comando en vez del create, comprueba que es lo que ya tenemos, si el objeto
    no existe lo creao, si ya existe ve que diferencias hay y las aplica, por ej, esto sirve si queremos agreagar alguna etiqueta o algo mas al objeto ya creado.
    kubectl apply -f nginx.yaml

Existe varias forma de tratar un pod cuando se cae o algo anda mal, tenemos tras posibilidades, Always, OnFailure, Never.
    Always: le indicamos que se reinicie siempre (opcion predefinida).
    OnFailure: se reinicie solo si ha fallado.
    Never: que nunca se reinicie.
    se indica con la clausula: "restarPolicy: Always/OnFailure/Never" --> a nivel del contenedor(containers) dentro de las especificaciones(spec)

--show-labels: muestra informacion de los pods junto con sus respectivas etiquetas.
    kubectl get pod tomcat --show-labels
    kubectl get pods -o wide --show-labels
    -con el parametro -L le indicamos que nos creé una nueva columna cone sa etiqueta.
    kubectl get pod tomcat --show-labels -L (nombre-columna) --> podemos concatenar varios nombres de columnas.
    kubectl get pod tomcat --show-labels -L estado

label: podemos manejar o actualizar nuestros objetos para poder añadir o modificar las etiquetas.
    kubectl label pod nombre-pod etiqueta-objeto=nombre-objeto
    kubectl laber pod tomcat responsable=Juan

--overwrite: nos permite sobreescribir el laber/etiqueta de une stado.
    kubectl label --overwrite pod nombre-pod etiqueta-objeto=nombre-objeto
    kubectl label --overwrite od tomcat estado=test (antes era estado=desarrollo)

Para borrar una etiqueta no existe un comando DELETE como tal, entonces lo podemos hacer de la siguiente manera.
    kubectl label pod/tomcat responsable- (agregamos un "-" en el laber que queremos borrar)

-- SELECTORES --

Son el objeto primario con el que se relacionan algunos de los componentes, como los deployment, servicios, etc.
Con como los "where" que se utilizan con una determianda condicion para encontrar determinados objetos con una determinada etiqueta.

-l/--selector: nos permite aplicar un selector en nuestro cluster, en este caso vamos a buscar los labels con un determinado estado.
    kubectl get pods --show-labels -l estado=desarrollo
    -Podemos poner condiciones, por ej   
    kubectl get pods --show-labels -l estado=desarrollo, responsable=Juan
    -Podemos ir por la negacion con el caracter "!" (responsable!=Juan)
    kubectl get pods --show-labels -l estado=desarrollo, responsable!=Juan
    -Se puede aplicar condiciones en forma de conjuntos con otros operadores, por ejemplo el "in" 'estado in(desarrollo)'
    kubectl get pods --show-labels -l 'estado in (desarrollo)'
    -Tambien se le pueden poner mas de un estado en fomra de listas, por ejemplo estado in(desarrollo,testind)'
    -Podemos usar los selectores para borrar un conjunto de PODS, por ejemplo.
    kubectl delete pods -l 'estado=desarrollo

-- ANOTACIONES --

Son similares a los labels, pero son mas bien descriptivas (al mismo nivel que label y name dentro de metadata).
    metadata:
        name: tomcat1
        labels:
            estado: "desarrollo"
            responsable: "Juan"
        annotations:
            doc: "se debe compliar con gcc"
            adjunto: "ejmplo de anotacion"
podemos ver o buscar luego con un describe, tambien podemos usar un jsonpath, por ej.
    kubectl get pod tomcat1 -o jsonpath={.metadata.annotations}


-- DEPLOYMENTS --

Despliega uno o un conjunto de PODS.

create: crea un deployment.
    kubectl create deployment nombre --image=nombre-de-imagen
    kubectl create deployment apache --image=httpd

get deployment: muestra los deployment del cluster.
    kubectl get deployment

get rs(replica set): muestra las replicas sets.
    kubectl get rs

describe: muestra informacion del deployment.
    kubectl describe tipo-objeto nombre-deployment
    kubectl describe deploy apache

-o yaml/json: presenta la informacion en cualquiera de esos dos formatos.
    kubectl get deploy apache -o yaml/json

    -- ESTRUCTURA DE UN DEPLOY .YAML --
    apiVersion: apps/v1 # i se Usa apps/v1beta2 para versiones anteriores a 1.9.0
    kind: Deployment
    metadata:
    name: nginx-d
    spec:
    selector: #permite seleccionar un conjunto de objetos que cumplan las condiciones.
        matchLabels:
        app: nginx
    replica: 2 #inidca al controlador que ejecute 2 pods.
    template: # planilla que define a los containers.
        metadata:
        labels:
            app: nginx
        spec:
        containers:
        - name: nginx
            image: nginx:1.7.9
            ports:
            - containerPort: 80

edit: nos permite editar un deploy sin necesitad del fichero yaml.
    kubectl edit deploy nginx-d 

scale: nos permite escalar un deploy de manera manual
    kubectl scale deploy nombre-del-deploy --replicas=(numero-de-deploy)
    kubectl scale deploy nginx-d --replicas=2

Para poder asignar recursos como memoria a un Pod, debemos hacer en la seccion de los contenedores.
    spec:
       containers:
       - name: nginx
         image: nginx
         ports:
         - containerPort: 80
         resources:
            limits: --> Indica el consumo maximo de memoria.
              memory: "200Mi"
            requests: --> Indica la memoria inicial con la que arrancaría el contenedor.
              memory: "100M"

Lo mismo aplica para la CPU.
            resources:
            limits: --> Indica el consumo maximo de memoria.
              memory: "200Mi"
              cpu: "2"
            requests: --> Indica la memoria inicial con la que arrancaría el contenedor.
              memory: "100M"
              cpu: "0.5"
 
 -- SERVICIOS --

Contamos con varios tipos de servicios.
 1. ClusterIP: Accesible solo desde dentro del Cluster (IP, NOMBRE, PUERTO)
 2. NodePort: Accesible desde fuera del Cluster (IP, NOMBRE, PUERTO, NODEPORT)
 3. LoadBalancer: Similar al NodePort, accesible desde fuera del Cluster. Integrado con LoadBalancer de terceros, como ser AWS, GOOGLE CLOUD, AZURE.

svc: comando para ver los servicios disponibles.
    kubectl get svc
    -tambien podemos usar el siguiente comando.
    kubectl describe svc web-svc

expose: comando que crea un servicio para exponer un deploy del cluster al exterior.
    kubectl expose deployment nombre-deploy --name=nombre-del-servicio --target-port=puerto-por-donde-ecucha-el-contenedor --type=tipo-puerto-externo
    kubectl expose deployment web-d --name=web-svc --target-port=80 --type=NodePort

ip: nos indica la ip del cluster minikube.
    minikube ip

-ESTRUCTURA YAML-
    apiVersion: v1
    kind: Service
    metadata:
    name: web-svc
    labels:
        app: web
    spec:
    type: NodePort -> tipo de servicio
    ports:
    - port: 80 -> Puerto de los contenedores
        nodePort: 30001 -> Puerto por el cual accederemos a nuestras aplicaciones junto con la IP del cluster.
        protocol: TCP
    selector:
        app: web --> indica o relaciona los pods y deploys con este servicio que se esta creando.

strategy: tenemos 2 tipos de estrategia, RollingUpdate(mas común) y el Recreate, Ambos van dentro de spec, a nivel del "selector" o "replicas" en el archivo YAML.
    RollingUpdate: va modificando los pods, de manera evolutiva(creando de poco a poco) para que asi tengamos pods que vayan dando servicios, los pods
    se van sustituyendo con las nuevas veriones.
    Recreate: directamente borra todos los pods y luego se carga por la nueva version, de esta manera nos quedamos sin servicio hasta que la nueva version este UP.
        strategy:
            type: RollingUpdate/Recreate

rollout history: nos muestra el historial del rollout(despliegues) que tiene un determinado deploy.
    kubectl rollout history deploy nombre-deploy
    kubectl rollout history deploy nginx-d 
    -podemos ver el detalle de cada revicion, con el parametro --revision=(numero-de-revision)
    kubectl rollout history deploy nginx-d --revision=1 

status: nos inidca el estado el rollout.
    kubectl rollout status deploy nombre-del-deploy
    kubectl rollout status deploy nginx-d 

rollout undo: volvemos atras en un rollout determinado.
    kubectl rollout undo deploy nombre-del-deploy --to-revision=numero-revision
    kubectl rollout undo deploy nginx-d --to-revision=2